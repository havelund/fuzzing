#!/usr/bin/python3
###############################################################################
# Copyright 2021, by the California Institute of Technology.
# ALL RIGHTS RESERVED. United States Government Sponsorship
# acknowledged. Any commercial use must be negotiated with the Office
# of Technology Transfer at the California Institute of Technology.
#
# Information included herein is controlled under the International
# Traffic in Arms Regulations ("ITAR") by the U.S. Department of State.
# Export or transfer of this information to a Foreign Person or foreign
# entity requires an export license issued by the U.S. State Department
# or an ITAR exemption prior to the export or transfer.
###############################################################################

################################################################################
#  Wiki Page: https://wiki.jpl.nasa.gov/display/fswcore/autogen_instr_pkts.py
################################################################################

from __future__ import print_function
from __future__ import absolute_import
from __future__ import unicode_literals

from builtins import str
from past.builtins import basestring

from xml.etree import cElementTree as ET
from xml.etree.ElementTree import Element
from collections import OrderedDict
import json
import argparse
from argparse import RawTextHelpFormatter
import os
import sys
import re

try:
    sys.path.insert(1, os.path.join(os.environ['FIT_PL_ROOT'], 'eurc_bin/scmfwzrd'))
    from sstruct import *
except:
    print('ERROR: Could not import sstruct')
    raise
    exit(-1)

################################################################################
#  CONSTANTS & GLOBALS
################################################################################

GEN_ICMD_STRUCTS = False
GEN_CMD_STRUCTS = False
NA = 'None'

INSTRUMENTS = ['uvs',
               'radmon',
               'maspex',
               'pimsl',
               'pimsu',
               'mise',
               'suda',
               'ethemis',
               'reason',
               'eisnac',
               'eiswac',
               'ecm']

ITLM_PATH = 'src/{}_mgr/{}_mgr_ai_itlm.xml'

ICMD_PATH = 'src/{}_mgr/{}_mgr_ai_icmd.xml'
CMD_PATH = 'src/{}_mgr/{}_mgr_ai_cmd.xml'

HEADER_DATA = """
###############################################################################
# Copyright 2021, by the California Institute of Technology.
# ALL RIGHTS RESERVED. United States Government Sponsorship
# acknowledged. Any commercial use must be negotiated with the Office
# of Technology Transfer at the California Institute of Technology.
#
# Information included herein is controlled under the International
# Traffic in Arms Regulations ("ITAR") by the U.S. Department of State.
# Export or transfer of this information to a Foreign Person or foreign
# entity requires an export license issued by the U.S. State Department
# or an ITAR exemption prior to the export or transfer.
###############################################################################

################################################################################
#  DO NOT EDIT - AUTOGENERATED by autogen_instr_pkts.py
################################################################################
from __future__ import absolute_import
from __future__ import unicode_literals

from eurc_bin.scmfwzrd.sstruct import *
"""

ENUM_DEF = """
enumDict = {
"""
DICT_DEF = """
cmdDict = {
"""
DICT_NAME_ITEMS = "'\t%s':\{"
DICT_ITEMS = "\t\t'{}':'{}',\n"
DICT_ARGS_BEGIN = "\t\t'args': [\n"

DICT_ARGS_ITEM_NAME = "{'name':'{}', "
DICT_ARGS_ITEM_TYPE = "'type':'{}', "

DICT_ARGS_ITEM_LENGTH = "'length':{},\n"
DICT_ARGS_ITEM_RANGE_MIN = "'range_min':'{}'},\n"
DICT_ARGS_ITEM_RANGE_MAX = "'range_max':'{}'},\n"

DICT_ARGS_END = """
\t\t      ]
\t\t},
"""

CLASS_DEF = """
class {}(SuperStruct):
    fields_desc = [
"""

BITFIELD_DEF = "        BitField('{}', {}),\n"

BITFIELD_DEFAULT_DEF = "        BitField('{}', {}, default={}),\n"

STRUCTFIELD_DEF = "        StructField('{}', {}),\n"

FIT_EXTRA_FIELD_NAME = 'FIT_SSTRUCT_PADDING'

class MyStruct(SuperStruct):
    fields_desc = []
my_struct = MyStruct()
SSTRUCT_RESERVED_TOKENS = dir(my_struct)

global struct_fields
global opcode_list


################################################################################
#  FUNCTIONS
################################################################################
def str2bool(v):
    if isinstance(v, bool):
       return v
    if v.lower() in ('yes', 'true', 't', 'y', '1'):
        return True
    elif v.lower() in ('no', 'false', 'f', 'n', '0'):
        return False
    else:
        raise argparse.ArgumentTypeError('Boolean value expected.')


        
def gen_cmd_file(fswpath, outdir, instr):
    # Find xml cmd definition file
    cmd_path = os.path.join(fswpath, CMD_PATH.format(instr, instr))

    if not os.path.isfile(cmd_path):
        print('ERROR: File not found: {}'.format(cmd_path))
        return -1

    # Reset list of cmd opcodes for this instrument
    global opcode_list
    opcode_list = []

    # Parse xml into tree structure
    tree = ET.parse(cmd_path)

    # Open an output file for packets
    pktpath = os.path.join(outdir, '{}Command.py'.format(instr.capitalize()))
    structpath = os.path.join(outdir, '{}CommandStructs.py'.format(instr.capitalize()))
    with open(pktpath, 'w') as pktfile, open(structpath, 'w') as structfile:
        # Create SuperStruct class for each defined packet
        root = tree.getroot()

        # Write Enum Structs
        enumStructs = root.find('enum_definitions')
        if enumStructs:
            pktfile.write(ENUM_DEF)
            
            for enumroot in enumStructs.findall('enum_table'):
#                print("in enumroot, %s"%enumroot.attrib['name'])
            
                # Generate python class definition
                write_enum_dicts(pktfile, enumroot)

            # Close class definition
            pktfile.write('}\n')
        
        # Write common dictionary header data
        pktfile.write(DICT_DEF)
        structfile.write(HEADER_DATA)
#        if GEN_CMD_STRUCTS:
#            pktfile.write('from {}CommandStructs import *\n'.format(instr.capitalize()))
 

        pkts = root.find('command_definitions')
        for pktroot in pkts.findall('fsw_command'):
            print("in pktroot, %s"%pktroot.attrib['stem'])
            
        for pktroot in pkts:

            # Generate python class definition
            write_cmd_packet_class(pktfile, structfile, pktroot)

        # Close class definition
        pktfile.write('}\n')

    print('CREATED: {}'.format(pktpath))
    if GEN_CMD_STRUCTS:
        print('CREATED: {}'.format(structpath))
    else:
        os.remove(structpath)


def write_enum_dicts(outfile,pktroot):
    global struct_fields
    global opcode_list
    enumname = pktroot.attrib['name']
    print("enum name is %s"%enumname)

    # Reset struct_fields for this class
    struct_fields = []
    
    # Name of Command
    outfile.write("\t'%s':[\n"%enumname)

    # Add values
    reserved = []
    if pktroot.find('values'):
#        outfile.write("'DICT_ARGS_BEGIN)
        for field in pktroot.find('values'):
#            print("enumroot arguments %s"%field.tag)

            write_enum(outfile, field, enumname)

#        outfile.write(DICT_ARGS_END)
        outfile.write("\t\t\t],\n")
    else:
        outfile.write('\t\t[],\n')

def write_cmd_packet_class(outfile, structfile, pktroot):
    global struct_fields
    global opcode_list
    cmdname = pktroot.attrib['stem']
    print("cmdname is %s"%cmdname)

    # Reset struct_fields for this class
    struct_fields = []
    skip_these_commands = ["DDM_DMP_EHA_PERIODIC","DDM_UPDATE_NUM_TSR","DDM_UPDATE_STR_TSR",
                           "DDM_DMP_EHA_HISTORY","GNC_IMU_WRITE_MEM","SEQ_VAR_CMD",
                           "SEQ_VAR_SEQ_ACTIVATE","SEQ_VAR_SEQ_LOAD","SEQ_VAR_SEQ_REACTIVATE",
                           "GNC_SRU_WRITE_MEMORY"]
    if cmdname in skip_these_commands:
        return
    
    # Name of Command
    outfile.write("\t'%s':{\n"%cmdname)

    # opcode
    # Add opcode field
    opcode = pktroot.attrib['opcode']
    print("pktname is %s, opcode is %s"%(cmdname,opcode))
    if opcode in opcode_list:
        print("WARNING: Duplicate opcodes in {}: opcode={}".format(outfile.name, opcode))
    opcode_list.append(opcode)
    outfile.write(DICT_ITEMS.format('opcode', opcode))

    # # # # TAC I DON'T THINK I NEED THE crc16 field
    # Add arguments
    reserved = []
    if pktroot.find('arguments'):
        outfile.write(DICT_ARGS_BEGIN)
        for field in pktroot.find('arguments'):
            print("pktroot arguments %s"%field.tag)

            name = write_field(outfile, field, reserved)
            reserved.append(name)

        outfile.write(DICT_ARGS_END)
    else:
        outfile.write('\t\t\'args\': []\n\t\t},\n')


def write_enum(outfile, node, enumName):
    global struct_fields

    #argument name
#    name = node.attrib['name']
    enumValue = node.attrib['symbol']
    print("this is in write_enum with enumname %s and enumvalue %s"%(enumName,enumValue))
    
#    outfile.write("\t\t\t{'%s':["%(enumName))
#    for field in node:
    outfile.write("\t\t\t'%s',\n"%enumValue)

        
    return

def write_field(outfile, node, reserved=[]):
    global struct_fields

    #argument name
    name = node.attrib['name']

    if node.tag == "var_string_arg":
#        print("this is var string arg")
        bit_length = node.attrib['max_bit_length']
        type = node.tag
        min = "None"
        max = "None"
        print("this is var string arg {} {} {}".format(name,node.tag,bit_length))
    elif node.tag == "enum_arg":
        bit_length = node.attrib['bit_length']
        type = node.attrib['enum_name']
        min = "None"
        max = "None"
        print("this is enum arg {} {} {}".format(name,node.tag, bit_length))
    elif node.tag == "unsigned_arg":
        bit_length = node.attrib['bit_length']
        type = node.tag
        for field in node:
            print("this is unsigned arg, in field loop")
            if field.tag == 'range_of_values':
                print("this is unsigned arg, in IF range of values")
                for range in field:
                    min = range.attrib['min']
                    max = range.attrib['max']
            else:
                min = "None"
                max = "None"
        print("this is unsigned arg {} {} {}".format(name,node.tag,bit_length))
                
    elif node.tag == "float_arg":
        print("TAC TAC this is float arg")
        bit_length = node.attrib['bit_length']
        type = node.tag
        for field in node:
            if field == 'range_of_values':
                for range in field:
                    min = range.attrib['min']
                    max = range.attrib['max']
            else:
                min = "None"
                max = "None"
    elif node.tag == "integer_arg":
        print("TAC TAC this is integer arg")
        bit_length = node.attrib['bit_length']
        type = node.tag
        for field in node:
            if field == 'range_of_values':
                for range in field:
                    min = range.attrib['min']
                    max = range.attrib['max']
            else:
                min = "None"
                max = "None"
    elif node.tag == "repeat_arg":
        print("TAC TAC TAC This needs work. There are 11 of these. Maybe ignore these commands until we have everything else working.  this is repeat arg")
        bit_length = node.attrib['bit_length']
        type = node.tag
        min = "None"
        max = "None"
    else:
        bit_length = 0

    outfile.write("\t\t\t{'name':'%s','type':'%s','length':%s,'range_min':%s,'range_max':%s},\n"%(name,type,bit_length,min,max))
        
    return


def write_eha_dict_mapping(outfile, pktroot):
    dictname = pktroot.attrib['packet_name'].upper() + '_EHA_MAP'
    
    # Build dict mapping (EHA -> itlm field)
    ehadict = OrderedDict()
    for field in pktroot.find('fields'):
        if 'flight_channel_map' in field.attrib:
            channel = field.attrib['flight_channel_map']
            itlm_field = field.attrib['name']
            ehadict[channel] = itlm_field

    # Write nothing if empty
    if len(ehadict) == 0:
        return

    # Write dict definition
    outfile.write('\n{} = \\\n'.format(dictname))
    outfile.write(json.dumps(ehadict, indent=4) + '\n')


################################################################################
#  MAIN
################################################################################

desc = """This tool generates python sstruct classes that describe instrument
command and telemetry packets using the following xml definition files:
    <instr>_mgr_ai_itlm.xml
    <instr>_mgr_ai_icmd.xml

A path to the desired fsw version directory is required.

The following output files will be generated for each instrument manager:
    <Instr>Telem.py
    <Instr>TelemStructs.py
    <Instr>Cmd.py
    <Instr>CmdStructs.py   -- by default these will not be generated, see -s flag

This tool will print the following to stdout:
    INFO: informational message
    CREATED: <new_file_path>
        -- when a new file is created
    WARNING: Duplicate opcodes in <path>: opcode=<value>
        -- when duplicate icmd opcodes are detected within an instrument manager
    ERROR: error message
        -- when the tool was not able to run successfully
"""
parser = argparse.ArgumentParser(description=desc, formatter_class=RawTextHelpFormatter)
parser.add_argument('fswpath', type=str, help='root of desired eurcfsw repo')
parser.add_argument('-o', '--outdir', type=str, default='.',
    help='directory for output files (default: pwd)')
parser.add_argument('-s', '--structs', action='store_true',
    help='generate InstrCmdStructs.py files,\ncurrently unnecessary but capability exists')
parser.add_argument('-i', '--instrument', type=str, default=None,
    help='instrument name for single instrument generation mode (default: all instruments)')
parser.add_argument('-p', '--padding', type=str2bool, default=True,
    help='boolean to add FIT padding bits to ensure importable files, note that these will NOT be structured identically to the FSW packets (default: True)')

args = parser.parse_args()

if not os.path.exists(args.fswpath):
    print('ERROR: Path not found: {}'.format(args.fswpath))
    exit(-1)

if not os.path.exists(args.outdir):
    os.mkdir(args.outdir)
    print('Created output directory: {}'.format(args.outdir))

if args.structs:
    GEN_ICMD_STRUCTS = True
    GEN_CMD_STRUCTS = True


if args.padding:
    print('INFO: Adding FIT padding bits to structs as needed to ensure importability of .py files')
else:
    print('NFO: NOT Adding FIT padding bits to structs')

if args.instrument is not None:
    gen_cmd_file(args.fswpath, args.outdir, args.instrument)
else:
    for instr in INSTRUMENTS:
        gen_cmd_file(args.fswpath, args.outdir, instr)
